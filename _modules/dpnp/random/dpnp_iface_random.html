

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>dpnp.random.dpnp_iface_random &mdash; dpnp 0.2 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> dpnp
          

          
          </a>

          
            
            
              <div class="version">
                0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dpnp_backend_api.html">C++ backend API Reference</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">dpnp</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>dpnp.random.dpnp_iface_random</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for dpnp.random.dpnp_iface_random</h1><div class="highlight"><pre>
<span></span><span class="c1"># cython: language_level=3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># *****************************************************************************</span>
<span class="c1"># Copyright (c) 2016-2020, Intel Corporation</span>
<span class="c1"># All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions are met:</span>
<span class="c1"># - Redistributions of source code must retain the above copyright notice,</span>
<span class="c1">#   this list of conditions and the following disclaimer.</span>
<span class="c1"># - Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#   this list of conditions and the following disclaimer in the documentation</span>
<span class="c1">#   and/or other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="c1"># AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="c1"># IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="c1"># ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</span>
<span class="c1"># LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="c1"># CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="c1"># SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="c1"># INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="c1"># CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="c1"># ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</span>
<span class="c1"># THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1"># *****************************************************************************</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module Intel NumPy Random</span>

<span class="sd">Set of functions to implement NumPy random module API</span>

<span class="sd">    .. seealso:: :obj:`numpy.random`</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">dpnp</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">dpnp.backend</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">dpnp.dparray</span> <span class="kn">import</span> <span class="n">dparray</span>
<span class="kn">from</span> <span class="nn">dpnp.dpnp_utils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">dpnp.random._random</span> <span class="kn">import</span> <span class="o">*</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;beta&#39;</span><span class="p">,</span>
    <span class="s1">&#39;binomial&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bytes&#39;</span><span class="p">,</span>
    <span class="s1">&#39;chisquare&#39;</span><span class="p">,</span>
    <span class="s1">&#39;exponential&#39;</span><span class="p">,</span>
    <span class="s1">&#39;gamma&#39;</span><span class="p">,</span>
    <span class="s1">&#39;geometric&#39;</span><span class="p">,</span>
    <span class="s1">&#39;gumbel&#39;</span><span class="p">,</span>
    <span class="s1">&#39;hypergeometric&#39;</span><span class="p">,</span>
    <span class="s1">&#39;laplace&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lognormal&#39;</span><span class="p">,</span>
    <span class="s1">&#39;negative_binomial&#39;</span><span class="p">,</span>
    <span class="s1">&#39;normal&#39;</span><span class="p">,</span>
    <span class="s1">&#39;poisson&#39;</span><span class="p">,</span>
    <span class="s1">&#39;rand&#39;</span><span class="p">,</span>
    <span class="s1">&#39;randint&#39;</span><span class="p">,</span>
    <span class="s1">&#39;randn&#39;</span><span class="p">,</span>
    <span class="s1">&#39;random&#39;</span><span class="p">,</span>
    <span class="s1">&#39;random_integers&#39;</span><span class="p">,</span>
    <span class="s1">&#39;random_sample&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ranf&#39;</span><span class="p">,</span>
    <span class="s1">&#39;rayleigh&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sample&#39;</span><span class="p">,</span>
    <span class="s1">&#39;seed&#39;</span><span class="p">,</span>
    <span class="s1">&#39;standard_cauchy&#39;</span><span class="p">,</span>
    <span class="s1">&#39;standard_exponential&#39;</span><span class="p">,</span>
    <span class="s1">&#39;standard_gamma&#39;</span><span class="p">,</span>
    <span class="s1">&#39;standard_normal&#39;</span><span class="p">,</span>
    <span class="s1">&#39;uniform&#39;</span><span class="p">,</span>
    <span class="s1">&#39;weibull&#39;</span>
<span class="p">]</span>


<div class="viewcode-block" id="beta"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.beta.html#dpnp.random.beta">[docs]</a><span class="k">def</span> <span class="nf">beta</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Beta distribution.</span>

<span class="sd">    Draw samples from a Beta distribution.</span>

<span class="sd">    The Beta distribution is a special case of the Dirichlet distribution,</span>
<span class="sd">    and is related to the Gamma distribution.  It has the probability</span>
<span class="sd">    distribution function</span>

<span class="sd">    .. math:: f(x; a,b) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1}</span>
<span class="sd">                                                     (1 - x)^{\\beta - 1},</span>

<span class="sd">    where the normalization, B, is the beta function,</span>

<span class="sd">    .. math:: B(\\alpha, \\beta) = \\int_0^1 t^{\\alpha - 1}</span>
<span class="sd">                                 (1 - t)^{\\beta - 1} dt.</span>

<span class="sd">    It is often seen in Bayesian inference and order statistics.</span>

<span class="sd">    .. note::</span>
<span class="sd">        New code should use the ``beta`` method of a ``default_rng()``</span>
<span class="sd">        instance instead; please see the :ref:`random-quick-start`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : float</span>
<span class="sd">        Alpha, positive (&gt;0).</span>
<span class="sd">    b : float</span>
<span class="sd">        Beta, positive (&gt;0).</span>
<span class="sd">    size : int or tuple of ints, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  If size is ``None`` (default),</span>
<span class="sd">        a single value is returned if ``a`` and ``b`` are both scalars.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dparray</span>
<span class="sd">        Drawn samples from the parameterized beta distribution.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO:</span>
    <span class="c1"># array_like of floats for `a`, `b`</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dpnp_queue_is_cpu</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">pass</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dpnp_beta</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="binomial"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.binomial.html#dpnp.random.binomial">[docs]</a><span class="k">def</span> <span class="nf">binomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Binomial distribution.</span>

<span class="sd">    Draw samples from a binomial distribution.</span>

<span class="sd">    Samples are drawn from a binomial distribution with specified</span>
<span class="sd">    parameters, n trials and p probability of success where</span>
<span class="sd">    n an integer &gt;= 0 and p is in the interval [0,1]. (n may be</span>
<span class="sd">    input as a float, but it is truncated to an integer in use)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Parameter of the distribution, &gt;= 0. Floats are also accepted,</span>
<span class="sd">        but they will be truncated to integers.</span>
<span class="sd">    p : float</span>
<span class="sd">        Parameter of the distribution, &gt;= 0 and &lt;=1.</span>
<span class="sd">    size : int or tuple of ints, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  If size is ``None`` (default),</span>
<span class="sd">        a single value is returned if ``n`` and ``p`` are both scalars.</span>
<span class="sd">        Otherwise, ``np.broadcast(n, p).size`` samples are drawn.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dparray, int32</span>
<span class="sd">        Drawn samples from the parameterized binomial distribution, where</span>
<span class="sd">        each sample is equal to the number of successes over the n trials.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The probability density for the binomial distribution is</span>

<span class="sd">    .. math:: P(N) = \\binom{n}{N}p^N(1-p)^{n-N},</span>

<span class="sd">    where :math:`n` is the number of trials, :math:`p` is the probability</span>
<span class="sd">    of success, and :math:`N` is the number of successes.</span>

<span class="sd">    When estimating the standard error of a proportion in a population by</span>
<span class="sd">    using a random sample, the normal distribution works well unless the</span>
<span class="sd">    product p*n &lt;=5, where p = population proportion estimate, and n =</span>
<span class="sd">    number of samples, in which case the binomial distribution is used</span>
<span class="sd">    instead. For example, a sample of 15 people shows 4 who are left</span>
<span class="sd">    handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4,</span>
<span class="sd">    so the binomial distribution should be used in this case.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Dalgaard, Peter, &quot;Introductory Statistics with R&quot;,</span>
<span class="sd">           Springer-Verlag, 2002.</span>
<span class="sd">    .. [2] Glantz, Stanton A. &quot;Primer of Biostatistics.&quot;, McGraw-Hill,</span>
<span class="sd">           Fifth Edition, 2002.</span>
<span class="sd">    .. [3] Lentner, Marvin, &quot;Elementary Applied Statistics&quot;, Bogden</span>
<span class="sd">           and Quigley, 1972.</span>
<span class="sd">    .. [4] Weisstein, Eric W. &quot;Binomial Distribution.&quot; From MathWorld--A</span>
<span class="sd">           Wolfram Web Resource.</span>
<span class="sd">           http://mathworld.wolfram.com/BinomialDistribution.html</span>
<span class="sd">    .. [5] Wikipedia, &quot;Binomial distribution&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Binomial_distribution</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Draw samples from the distribution:</span>
<span class="sd">    &gt;&gt;&gt; n, p = 10, .5  # number of trials, probability of each trial</span>
<span class="sd">    &gt;&gt;&gt; s = dpnp.random.binomial(n, p, 1000)</span>
<span class="sd">    # result of flipping a coin 10 times, tested 1000 times.</span>
<span class="sd">    A real world example. A company drills 9 wild-cat oil exploration</span>
<span class="sd">    wells, each with an estimated probability of success of 0.1. All nine</span>
<span class="sd">    wells fail. What is the probability of that happening?</span>
<span class="sd">    Let&#39;s do 20,000 trials of the model, and count the number that</span>
<span class="sd">    generate zero positive results.</span>
<span class="sd">    &gt;&gt;&gt; sum(dpnp.random.binomial(9, 0.1, 20000) == 0)/20000.</span>
<span class="sd">    # answer = 0.38885, or 38%.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dpnp_queue_is_cpu</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;binomial&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;binomial&quot;</span><span class="p">,</span> <span class="s2">&quot;type(size)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="c1"># TODO:</span>
        <span class="c1"># array_like of floats for `p` param</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;binomial&quot;</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="s2">&quot;in [0, 1]&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;binomial&quot;</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot;non-negative&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dpnp_binomial</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="bytes"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.bytes.html#dpnp.random.bytes">[docs]</a><span class="k">def</span> <span class="nf">bytes</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Bytes</span>

<span class="sd">    Return random bytes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    length : int</span>
<span class="sd">        Number of random bytes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : str</span>
<span class="sd">        String of length `length`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; dpnp.random.bytes(10)</span>
<span class="sd">    &#39; eh\\x85\\x022SZ\\xbf\\xa4&#39; #random</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">bytes</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span></div>


<div class="viewcode-block" id="chisquare"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.chisquare.html#dpnp.random.chisquare">[docs]</a><span class="k">def</span> <span class="nf">chisquare</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    chisquare(df, size=None)</span>

<span class="sd">    Draw samples from a chi-square distribution.</span>

<span class="sd">    When `df` independent random variables, each with standard normal</span>
<span class="sd">    distributions (mean 0, variance 1), are squared and summed, the</span>
<span class="sd">    resulting distribution is chi-square (see Notes).  This distribution</span>
<span class="sd">    is often used in hypothesis testing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : float</span>
<span class="sd">         Number of degrees of freedom, must be &gt; 0.</span>
<span class="sd">    size : int or tuple of ints, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  If size is ``None`` (default),</span>
<span class="sd">        a single value is returned if ``df`` is a scalar.  Otherwise,</span>
<span class="sd">        ``np.array(df).size`` samples are drawn.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray or scalar</span>
<span class="sd">        Drawn samples from the parameterized chi-square distribution.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        When `df` &lt;= 0 or when an inappropriate `size` (e.g. ``size=-1``)</span>
<span class="sd">        is given.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; dpnp.random.chisquare(2,4)</span>
<span class="sd">    array([ 1.89920014,  9.00867716,  3.13710533,  5.62318272]) # random</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dpnp_queue_is_cpu</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;chisquare&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;chisquare&quot;</span><span class="p">,</span> <span class="s2">&quot;type(size)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="c1"># TODO:</span>
        <span class="c1"># array_like of floats for `df`</span>
        <span class="c1"># add check for df array like, after adding array-like interface for df param</span>
        <span class="k">if</span> <span class="n">df</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;chisquare&quot;</span><span class="p">,</span> <span class="s2">&quot;df&quot;</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="s2">&quot;positive&quot;</span><span class="p">)</span>
        <span class="c1"># TODO:</span>
        <span class="c1"># float to int, safe</span>
        <span class="k">return</span> <span class="n">dpnp_chisquare</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">chisquare</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="exponential"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.exponential.html#dpnp.random.exponential">[docs]</a><span class="k">def</span> <span class="nf">exponential</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Exponential distribution.</span>

<span class="sd">    Draw samples from an exponential distribution.</span>

<span class="sd">    Its probability density function is</span>

<span class="sd">    .. math:: f(x; \\frac{1}{\\beta}) = \\frac{1}{\\beta} \\exp(-\\frac{x}{\\beta}),</span>

<span class="sd">    for ``x &gt; 0`` and 0 elsewhere. :math:`\\beta` is the scale parameter,</span>
<span class="sd">    which is the inverse of the rate parameter :math:`\\lambda = 1/\\beta`.</span>
<span class="sd">    The rate parameter is an alternative, widely used parameterization</span>
<span class="sd">    of the exponential distribution [3]_.</span>

<span class="sd">    The exponential distribution is a continuous analogue of the</span>
<span class="sd">    geometric distribution.  It describes many common situations, such as</span>
<span class="sd">    the size of raindrops measured over many rainstorms [1]_, or the time</span>
<span class="sd">    between page requests to Wikipedia [2]_.</span>

<span class="sd">    .. note::</span>
<span class="sd">        New code should use the ``exponential`` method of a ``default_rng()``</span>
<span class="sd">        instance instead; please see the :ref:`random-quick-start`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    scale : float</span>
<span class="sd">        The scale parameter, :math:`\\beta = 1/\\lambda`. Must be</span>
<span class="sd">        non-negative.</span>
<span class="sd">    size : int or tuple of ints, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  If size is ``None`` (default),</span>
<span class="sd">        a single value is returned if ``scale`` is a scalar.  Otherwise,</span>
<span class="sd">        ``np.array(scale).size`` samples are drawn.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dparray</span>
<span class="sd">        Drawn samples from the parameterized exponential distribution.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Peyton Z. Peebles Jr., &quot;Probability, Random Variables and</span>
<span class="sd">           Random Signal Principles&quot;, 4th ed, 2001, p. 57.</span>
<span class="sd">    .. [2] Wikipedia, &quot;Poisson process&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Poisson_process</span>
<span class="sd">    .. [3] Wikipedia, &quot;Exponential distribution&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Exponential_distribution</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">scale</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;exponential&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;exponential&quot;</span><span class="p">,</span> <span class="s2">&quot;type(size)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;exponential&quot;</span><span class="p">,</span> <span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="s2">&quot;non-negative&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dpnp_exponential</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">exponential</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="gamma"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.gamma.html#dpnp.random.gamma">[docs]</a><span class="k">def</span> <span class="nf">gamma</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Gamma distribution.</span>

<span class="sd">    Draw samples from a Gamma distribution.</span>

<span class="sd">    Samples are drawn from a Gamma distribution with specified parameters,</span>
<span class="sd">    `shape` (sometimes designated &quot;k&quot;) and `scale` (sometimes designated</span>
<span class="sd">    &quot;theta&quot;), where both parameters are &gt; 0.</span>

<span class="sd">    .. note::</span>
<span class="sd">        New code should use the ``gamma`` method of a ``default_rng()``</span>
<span class="sd">        instance instead; please see the :ref:`random-quick-start`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : float or array_like of floats</span>
<span class="sd">        The shape of the gamma distribution. Must be non-negative.</span>
<span class="sd">    scale : float or array_like of floats, optional</span>
<span class="sd">        The scale of the gamma distribution. Must be non-negative.</span>
<span class="sd">        Default is equal to 1.</span>
<span class="sd">    size : int or tuple of ints, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  If size is ``None`` (default),</span>
<span class="sd">        a single value is returned if ``shape`` and ``scale`` are both scalars.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dparray</span>
<span class="sd">        Drawn samples from the parameterized gamma distribution.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The probability density for the Gamma distribution is</span>

<span class="sd">    .. math:: p(x) = x^{k-1}\\frac{e^{-x/\\theta}}{\\theta^k\\Gamma(k)},</span>

<span class="sd">    where :math:`k` is the shape and :math:`\\theta` the scale,</span>
<span class="sd">    and :math:`\\Gamma` is the Gamma function.</span>

<span class="sd">    The Gamma distribution is often used to model the times to failure of</span>
<span class="sd">    electronic components, and arises naturally in processes for which the</span>
<span class="sd">    waiting times between Poisson distributed events are relevant.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Weisstein, Eric W. &quot;Gamma Distribution.&quot; From MathWorld--A</span>
<span class="sd">           Wolfram Web Resource.</span>
<span class="sd">           http://mathworld.wolfram.com/GammaDistribution.html</span>
<span class="sd">    .. [2] Wikipedia, &quot;Gamma distribution&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Gamma_distribution</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO:</span>
    <span class="c1"># array_like of floats for `scale` and `shape`</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dpnp_queue_is_cpu</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;gamma&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;gamma&quot;</span><span class="p">,</span> <span class="s2">&quot;type(size)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;gamma&quot;</span><span class="p">,</span> <span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="s2">&quot;non-negative&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;gamma&quot;</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;non-negative&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dpnp_gamma</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="geometric"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.geometric.html#dpnp.random.geometric">[docs]</a><span class="k">def</span> <span class="nf">geometric</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Geometric distribution.</span>

<span class="sd">    Draw samples from the geometric distribution.</span>

<span class="sd">    Bernoulli trials are experiments with one of two outcomes:</span>
<span class="sd">    success or failure (an example of such an experiment is flipping</span>
<span class="sd">    a coin).  The geometric distribution models the number of trials</span>
<span class="sd">    that must be run in order to achieve success.  It is therefore</span>
<span class="sd">    supported on the positive integers, ``k = 1, 2, ...``.</span>

<span class="sd">    The probability mass function of the geometric distribution is</span>

<span class="sd">    .. math:: f(k) = (1 - p)^{k - 1} p</span>

<span class="sd">    where `p` is the probability of success of an individual trial.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : float</span>
<span class="sd">        The probability of success of an individual trial.</span>
<span class="sd">    size : int or tuple of ints, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  If size is ``None`` (default),</span>
<span class="sd">        a single value is returned if ``p`` is a scalar.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dparray, int32</span>
<span class="sd">        Drawn samples from the parameterized geometric distribution.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Draw ten thousand values from the geometric distribution,</span>
<span class="sd">    with the probability of an individual success equal to 0.35:</span>
<span class="sd">    &gt;&gt;&gt; z = dpnp.random.geometric(p=0.35, size=10000)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;geometric&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;geometric&quot;</span><span class="p">,</span> <span class="s2">&quot;type(size)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="c1"># TODO:</span>
        <span class="c1"># array_like of floats for `p` param</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;geometric&quot;</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="s2">&quot;in (0, 1]&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dpnp_geometric</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">geometric</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="gumbel"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.gumbel.html#dpnp.random.gumbel">[docs]</a><span class="k">def</span> <span class="nf">gumbel</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Gumbel distribution.</span>

<span class="sd">    Draw samples from a Gumbel distribution.</span>

<span class="sd">    Draw samples from a Gumbel distribution with specified location and</span>
<span class="sd">    scale.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    loc : float, optional</span>
<span class="sd">        The location of the mode of the distribution. Default is 0.</span>
<span class="sd">    scale : float, optional</span>
<span class="sd">        The scale parameter of the distribution. Default is 1. Must be non-</span>
<span class="sd">        negative.</span>
<span class="sd">    size : int or tuple of ints, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  If size is ``None`` (default),</span>
<span class="sd">        a single value is returned if ``loc`` and ``scale`` are both scalars.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dparray</span>
<span class="sd">        Drawn samples from the parameterized Gumbel distribution.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Draw samples from the distribution:</span>
<span class="sd">    &gt;&gt;&gt; mu, beta = 0, 0.1 # location and scale</span>
<span class="sd">    &gt;&gt;&gt; s = dpnp.random.gumbel(mu, beta, 1000)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;gumbel&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;gumbel&quot;</span><span class="p">,</span> <span class="s2">&quot;type(size)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="c1"># TODO:</span>
        <span class="c1"># array_like of floats for `loc` and `scale` params</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;gumbel&quot;</span><span class="p">,</span> <span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="s2">&quot;non-negative&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dpnp_gumbel</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">gumbel</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="hypergeometric"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.hypergeometric.html#dpnp.random.hypergeometric">[docs]</a><span class="k">def</span> <span class="nf">hypergeometric</span><span class="p">(</span><span class="n">ngood</span><span class="p">,</span> <span class="n">nbad</span><span class="p">,</span> <span class="n">nsample</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Hypergeometric distribution.</span>

<span class="sd">    Draw samples from a Hypergeometric distribution.</span>

<span class="sd">    Samples are drawn from a hypergeometric distribution with specified</span>
<span class="sd">    parameters, `ngood` (ways to make a good selection), `nbad` (ways to make</span>
<span class="sd">    a bad selection), and `nsample` (number of items sampled, which is less</span>
<span class="sd">    than or equal to the sum ``ngood + nbad``).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ngood : int</span>
<span class="sd">        Number of ways to make a good selection.  Must be nonnegative.</span>
<span class="sd">    nbad : int</span>
<span class="sd">        Number of ways to make a bad selection.  Must be nonnegative.</span>
<span class="sd">    nsample : int</span>
<span class="sd">        Number of items sampled.  Must be at least 1 and at most</span>
<span class="sd">        ``ngood + nbad``.</span>
<span class="sd">    size : int or tuple of ints, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  If size is ``None`` (default),</span>
<span class="sd">        a single value is returned if `ngood`, `nbad`, and `nsample`</span>
<span class="sd">        are all scalars.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dparray</span>
<span class="sd">        Drawn samples from the parameterized hypergeometric distribution. Each</span>
<span class="sd">        sample is the number of good items within a randomly selected subset of</span>
<span class="sd">        size `nsample` taken from a set of `ngood` good items and `nbad` bad items.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The probability density for the Hypergeometric distribution is</span>

<span class="sd">    .. math:: P(x) = \\frac{\\binom{g}{x}\\binom{b}{n-x}}{\\binom{g+b}{n}},</span>

<span class="sd">    where :math:`0 \\le x \\le n` and :math:`n-b \\le x \\le g`</span>

<span class="sd">    for P(x) the probability of ``x`` good results in the drawn sample,</span>
<span class="sd">    g = `ngood`, b = `nbad`, and n = `nsample`.</span>

<span class="sd">    Consider an urn with black and white marbles in it, `ngood` of them</span>
<span class="sd">    are black and `nbad` are white. If you draw `nsample` balls without</span>
<span class="sd">    replacement, then the hypergeometric distribution describes the</span>
<span class="sd">    distribution of black balls in the drawn sample.</span>

<span class="sd">    Note that this distribution is very similar to the binomial</span>
<span class="sd">    distribution, except that in this case, samples are drawn without</span>
<span class="sd">    replacement, whereas in the Binomial case samples are drawn with</span>
<span class="sd">    replacement (or the sample space is infinite). As the sample space</span>
<span class="sd">    becomes large, this distribution approaches the binomial.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Lentner, Marvin, &quot;Elementary Applied Statistics&quot;, Bogden</span>
<span class="sd">           and Quigley, 1972.</span>
<span class="sd">    .. [2] Weisstein, Eric W. &quot;Hypergeometric Distribution.&quot; From</span>
<span class="sd">           MathWorld--A Wolfram Web Resource.</span>
<span class="sd">           http://mathworld.wolfram.com/HypergeometricDistribution.html</span>
<span class="sd">    .. [3] Wikipedia, &quot;Hypergeometric distribution&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Hypergeometric_distribution</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Draw samples from the distribution:</span>
<span class="sd">    &gt;&gt;&gt; ngood, nbad, nsamp = 100, 2, 10</span>
<span class="sd">    # number of good, number of bad, and number of samples</span>
<span class="sd">    &gt;&gt;&gt; s = dpnp.random.hypergeometric(ngood, nbad, nsamp, 1000)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">ngood</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dpnp_queue_is_cpu</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;hypergeometric&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;hypergeometric&quot;</span><span class="p">,</span> <span class="s2">&quot;type(size)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="c1"># TODO:</span>
        <span class="c1"># array_like of ints for `ngood`, `nbad`, `nsample` param</span>
        <span class="k">if</span> <span class="n">ngood</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;hypergeometric&quot;</span><span class="p">,</span> <span class="s2">&quot;ngood&quot;</span><span class="p">,</span> <span class="n">ngood</span><span class="p">,</span> <span class="s2">&quot;non-negative&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nbad</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;hypergeometric&quot;</span><span class="p">,</span> <span class="s2">&quot;nbad&quot;</span><span class="p">,</span> <span class="n">nbad</span><span class="p">,</span> <span class="s2">&quot;non-negative&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nsample</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;hypergeometric&quot;</span><span class="p">,</span> <span class="s2">&quot;nsample&quot;</span><span class="p">,</span> <span class="n">nsample</span><span class="p">,</span> <span class="s2">&quot;non-negative&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ngood</span> <span class="o">+</span> <span class="n">nbad</span> <span class="o">&lt;</span> <span class="n">nsample</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;hypergeometric&quot;</span><span class="p">,</span> <span class="s2">&quot;nsample&quot;</span><span class="p">,</span> <span class="n">nsample</span><span class="p">,</span> <span class="s2">&quot;ngood + nbad &gt;= nsample&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nsample</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;hypergeometric&quot;</span><span class="p">,</span> <span class="s2">&quot;nsample&quot;</span><span class="p">,</span> <span class="n">nsample</span><span class="p">,</span> <span class="s2">&quot;&gt;= 1&quot;</span><span class="p">)</span>


        <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ngood</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ngood</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">nbad</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nsample</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dpnp_hypergeometric</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">hypergeometric</span><span class="p">,</span> <span class="n">ngood</span><span class="p">,</span> <span class="n">nbad</span><span class="p">,</span> <span class="n">nsample</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="laplace"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.laplace.html#dpnp.random.laplace">[docs]</a><span class="k">def</span> <span class="nf">laplace</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Laplace distribution.</span>

<span class="sd">    Draw samples from the Laplace or double exponential distribution with</span>
<span class="sd">    specified location (or mean) and scale (decay).</span>

<span class="sd">    The Laplace distribution is similar to the Gaussian/normal distribution,</span>
<span class="sd">    but is sharper at the peak and has fatter tails. It represents the</span>
<span class="sd">    difference between two independent, identically distributed exponential</span>
<span class="sd">    random variables.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    loc : float, optional</span>
<span class="sd">        The position, :math:`\\mu`, of the distribution peak. Default is 0.</span>
<span class="sd">    scale : float, optional</span>
<span class="sd">        :math:`\\lambda`, the exponential decay. Default is 1. Must be non-</span>
<span class="sd">        negative.</span>
<span class="sd">    size : int or tuple of ints, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  If size is ``None`` (default),</span>
<span class="sd">        a single value is returned if ``loc`` and ``scale`` are both scalars.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dparray</span>
<span class="sd">        Drawn samples from the parameterized Laplace distribution.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; loc, scale = 0., 1.</span>
<span class="sd">    &gt;&gt;&gt; s = dpnp.random.laplace(loc, scale, 1000)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;laplace&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;laplace&quot;</span><span class="p">,</span> <span class="s2">&quot;type(size)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="c1"># TODO:</span>
        <span class="c1"># array_like of floats for `loc` and `scale` params</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;laplace&quot;</span><span class="p">,</span> <span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="s2">&quot;non-negative&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dpnp_laplace</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">laplace</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="lognormal"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.lognormal.html#dpnp.random.lognormal">[docs]</a><span class="k">def</span> <span class="nf">lognormal</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Lognormal distribution.</span>

<span class="sd">    Draw samples from a log-normal distribution.</span>

<span class="sd">    Draw samples from a log-normal distribution with specified mean,</span>
<span class="sd">    standard deviation, and array shape.  Note that the mean and standard</span>
<span class="sd">    deviation are not the values for the distribution itself, but of the</span>
<span class="sd">    underlying normal distribution it is derived from.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mean : float, optional</span>
<span class="sd">        Mean value of the underlying normal distribution. Default is 0.</span>
<span class="sd">    sigma : float, optional</span>
<span class="sd">        Standard deviation of the underlying normal distribution. Must be</span>
<span class="sd">        non-negative. Default is 1.</span>
<span class="sd">    size : int or tuple of ints, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  If size is ``None`` (default),</span>
<span class="sd">        a single value is returned if ``mean`` and ``sigma`` are both scalars.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dparray</span>
<span class="sd">        Drawn samples from the parameterized log-normal distribution.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A variable `x` has a log-normal distribution if `log(x)` is normally</span>
<span class="sd">    distributed.  The probability density function for the log-normal</span>
<span class="sd">    distribution is:</span>

<span class="sd">    .. math:: p(x) = \\frac{1}{\\sigma x \\sqrt{2\\pi}}</span>
<span class="sd">                     e^{(-\\frac{(ln(x)-\\mu)^2}{2\\sigma^2})}</span>

<span class="sd">    where :math:`\\mu` is the mean and :math:`\\sigma` is the standard</span>
<span class="sd">    deviation of the normally distributed logarithm of the variable.</span>
<span class="sd">    A log-normal distribution results if a random variable is the *product*</span>
<span class="sd">    of a large number of independent, identically-distributed variables in</span>
<span class="sd">    the same way that a normal distribution results if the variable is the</span>
<span class="sd">    *sum* of a large number of independent, identically-distributed</span>
<span class="sd">    variables.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Limpert, E., Stahel, W. A., and Abbt, M., &quot;Log-normal</span>
<span class="sd">           Distributions across the Sciences: Keys and Clues,&quot;</span>
<span class="sd">           BioScience, Vol. 51, No. 5, May, 2001.</span>
<span class="sd">           https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf</span>
<span class="sd">    .. [2] Reiss, R.D. and Thomas, M., &quot;Statistical Analysis of Extreme</span>
<span class="sd">           Values,&quot; Basel: Birkhauser Verlag, 2001, pp. 31-32.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Draw samples from the distribution:</span>
<span class="sd">    &gt;&gt;&gt; mu, sigma = 3., 1. # mean and standard deviation</span>
<span class="sd">    &gt;&gt;&gt; s = dpnp.random.lognormal(mu, sigma, 1000)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">mean</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;lognormal&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;lognormal&quot;</span><span class="p">,</span> <span class="s2">&quot;type(size)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="c1"># TODO:</span>
        <span class="c1"># array_like of floats for `mean` and `sigma` params</span>
        <span class="k">if</span> <span class="n">sigma</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;lognormal&quot;</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="s2">&quot;non-negative&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dpnp_lognormal</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">lognormal</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="negative_binomial"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.negative_binomial.html#dpnp.random.negative_binomial">[docs]</a><span class="k">def</span> <span class="nf">negative_binomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Negative binomial distribution.</span>

<span class="sd">    Draw samples from a negative binomial distribution.</span>

<span class="sd">    Samples are drawn from a negative binomial distribution with specified</span>
<span class="sd">    parameters, `n` successes and `p` probability of success where `n`</span>
<span class="sd">    is &gt; 0 and `p` is in the interval [0, 1].</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : float</span>
<span class="sd">        Parameter of the distribution, &gt; 0.</span>
<span class="sd">    p : float</span>
<span class="sd">        Parameter of the distribution, &gt;= 0 and &lt;=1.</span>
<span class="sd">    size : int or tuple of ints, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  If size is ``None`` (default),</span>
<span class="sd">        a single value is returned if ``n`` and ``p`` are both scalars.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dparray, int32</span>
<span class="sd">        Drawn samples from the parameterized negative binomial distribution,</span>
<span class="sd">        where each sample is equal to N, the number of failures that</span>
<span class="sd">        occurred before a total of n successes was reached.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The probability mass function of the negative binomial distribution is</span>

<span class="sd">    .. math:: P(N;n,p) = \\frac{\\Gamma(N+n)}{N!\\Gamma(n)}p^{n}(1-p)^{N},</span>

<span class="sd">    where :math:`n` is the number of successes, :math:`p` is the</span>
<span class="sd">    probability of success, :math:`N+n` is the number of trials, and</span>
<span class="sd">    :math:`\\Gamma` is the gamma function. When :math:`n` is an integer,</span>
<span class="sd">    :math:`\\frac{\\Gamma(N+n)}{N!\\Gamma(n)} = \\binom{N+n-1}{N}`, which is</span>
<span class="sd">    the more common form of this term in the the pmf. The negative</span>
<span class="sd">    binomial distribution gives the probability of N failures given n</span>
<span class="sd">    successes, with a success on the last trial.</span>

<span class="sd">    If one throws a die repeatedly until the third time a &quot;1&quot; appears,</span>
<span class="sd">    then the probability distribution of the number of non-&quot;1&quot;s that</span>
<span class="sd">    appear before the third &quot;1&quot; is a negative binomial distribution.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Weisstein, Eric W. &quot;Negative Binomial Distribution.&quot; From</span>
<span class="sd">           MathWorld--A Wolfram Web Resource.</span>
<span class="sd">           http://mathworld.wolfram.com/NegativeBinomialDistribution.html</span>
<span class="sd">    .. [2] Wikipedia, &quot;Negative binomial distribution&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Negative_binomial_distribution</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Draw samples from the distribution:</span>
<span class="sd">    A real world example. A company drills wild-cat oil</span>
<span class="sd">    exploration wells, each with an estimated probability of</span>
<span class="sd">    success of 0.1.  What is the probability of having one success</span>
<span class="sd">    for each successive well, that is what is the probability of a</span>
<span class="sd">    single success after drilling 5 wells, after 6 wells, etc.?</span>

<span class="sd">    &gt;&gt;&gt; s = dpnp.random.negative_binomial(1, 0.1, 100000)</span>
<span class="sd">    &gt;&gt;&gt; for i in range(1, 11): # doctest: +SKIP</span>
<span class="sd">    ...    probability = sum(s&lt;i) / 100000.</span>
<span class="sd">    ...    print(i, &quot;wells drilled, probability of one success =&quot;, probability)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dpnp_queue_is_cpu</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;negative_binomial&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;negative_binomial&quot;</span><span class="p">,</span> <span class="s2">&quot;type(size)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="c1"># TODO:</span>
        <span class="c1"># array_like of floats for `p` and `n` params</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;negative_binomial&quot;</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="s2">&quot;in [0, 1]&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;negative_binomial&quot;</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot;non-negative&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dpnp_negative_binomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">negative_binomial</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="normal"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.normal.html#dpnp.random.normal">[docs]</a><span class="k">def</span> <span class="nf">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Normal distribution.</span>

<span class="sd">    Draw random samples from a normal (Gaussian) distribution.</span>

<span class="sd">    The probability density function of the normal distribution, first</span>
<span class="sd">    derived by De Moivre and 200 years later by both Gauss and Laplace</span>
<span class="sd">    independently [2]_, is often called the bell curve because of</span>
<span class="sd">    its characteristic shape (see the example below).</span>

<span class="sd">    The normal distributions occurs often in nature.  For example, it</span>
<span class="sd">    describes the commonly occurring distribution of samples influenced</span>
<span class="sd">    by a large number of tiny, random disturbances, each with its own</span>
<span class="sd">    unique distribution [2]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    loc : float</span>
<span class="sd">        Mean (&quot;centre&quot;) of the distribution.</span>
<span class="sd">    scale : float</span>
<span class="sd">        Standard deviation (spread or &quot;width&quot;) of the distribution. Must be</span>
<span class="sd">        non-negative.</span>
<span class="sd">    size : int or tuple of ints, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  If size is ``None`` (default),</span>
<span class="sd">        a single value is returned if ``loc`` and ``scale`` are both scalars.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dparray</span>
<span class="sd">        Drawn samples from the parameterized normal distribution.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The probability density for the Gaussian distribution is</span>

<span class="sd">    .. math:: p(x) = \\frac{1}{\\sqrt{ 2 \\pi \\sigma^2 }}</span>
<span class="sd">                     e^{ - \\frac{ (x - \\mu)^2 } {2 \\sigma^2} },</span>

<span class="sd">    where :math:`\\mu` is the mean and :math:`\\sigma` the standard</span>
<span class="sd">    deviation. The square of the standard deviation, :math:`\\sigma^2`,</span>
<span class="sd">    is called the variance.</span>

<span class="sd">    The function has its peak at the mean, and its &quot;spread&quot; increases with</span>
<span class="sd">    the standard deviation (the function reaches 0.607 times its maximum at</span>
<span class="sd">    :math:`x + \\sigma` and :math:`x - \\sigma` [2]_).  This implies that</span>
<span class="sd">    normal is more likely to return samples lying close to the mean, rather</span>
<span class="sd">    than those far away.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia, &quot;Normal distribution&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Normal_distribution</span>
<span class="sd">    .. [2] P. R. Peebles Jr., &quot;Central Limit Theorem&quot; in &quot;Probability,</span>
<span class="sd">           Random Variables and Random Signal Principles&quot;, 4th ed., 2001,</span>
<span class="sd">           pp. 51, 51, 125.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Draw samples from the distribution:</span>
<span class="sd">    &gt;&gt;&gt; mu, sigma = 0, 0.1 # mean and standard deviation</span>
<span class="sd">    &gt;&gt;&gt; s = dpnp.random.normal(mu, sigma, 1000)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;normal&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;normal&quot;</span><span class="p">,</span> <span class="s2">&quot;type(size)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="c1"># TODO:</span>
        <span class="c1"># array_like of floats for `loc` and `scale` params</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;normal&quot;</span><span class="p">,</span> <span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="s2">&quot;non-negative&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dpnp_normal</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="poisson"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.poisson.html#dpnp.random.poisson">[docs]</a><span class="k">def</span> <span class="nf">poisson</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Poisson distribution.</span>

<span class="sd">    Draw samples from a Poisson distribution.</span>

<span class="sd">    The Poisson distribution is the limit of the binomial distribution</span>
<span class="sd">    for large N.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lam : float</span>
<span class="sd">        Expectation of interval, must be &gt;= 0. A sequence of expectation</span>
<span class="sd">        intervals must be broadcastable over the requested size.</span>
<span class="sd">    size : int, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  If size is ``None`` (default),</span>
<span class="sd">        a single value is returned if ``lam`` is a scalar.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dparray, int32</span>
<span class="sd">        Drawn samples from the parameterized Poisson distribution.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Poisson distribution</span>

<span class="sd">    .. math:: f(k; \\lambda)=\\frac{\\lambda^k e^{-\\lambda}}{k!}</span>

<span class="sd">    For events with an expected separation :math:`\\lambda` the Poisson</span>
<span class="sd">    distribution :math:`f(k; \\lambda)` describes the probability of</span>
<span class="sd">    :math:`k` events occurring within the observed</span>
<span class="sd">    interval :math:`\\lambda`.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Weisstein, Eric W. &quot;Poisson Distribution.&quot;</span>
<span class="sd">           From MathWorld--A Wolfram Web Resource.</span>
<span class="sd">           http://mathworld.wolfram.com/PoissonDistribution.html</span>
<span class="sd">    .. [2] Wikipedia, &quot;Poisson distribution&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Poisson_distribution</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Draw samples from the distribution:</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; s = dpnp.random.poisson(5, 10000)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">lam</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;poisson&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;poisson&quot;</span><span class="p">,</span> <span class="s2">&quot;type(size)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="c1"># TODO:</span>
        <span class="c1"># array_like of floats for `lam` param</span>
        <span class="k">if</span> <span class="n">lam</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;poisson&quot;</span><span class="p">,</span> <span class="s2">&quot;lam&quot;</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="s2">&quot;non-negative&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dpnp_poisson</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">poisson</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="rand"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.rand.html#dpnp.random.rand">[docs]</a><span class="k">def</span> <span class="nf">rand</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span> <span class="o">*</span><span class="n">dn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an array of the given shape and populate it</span>
<span class="sd">    with random samples from a uniform distribution over [0, 1).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d0, d1, …, dn : The dimensions of the returned array, must be non-negative.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : Random values.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.random.random`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">d0</span><span class="p">):</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">d0</span><span class="p">,</span> <span class="o">*</span><span class="n">dn</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;rand&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dpnp_random</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">,</span> <span class="n">d0</span><span class="p">,</span> <span class="o">*</span><span class="n">dn</span><span class="p">)</span></div>


<div class="viewcode-block" id="randint"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.randint.html#dpnp.random.randint">[docs]</a><span class="k">def</span> <span class="nf">randint</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    randint(low, high=None, size=None, dtype=int)</span>

<span class="sd">    Return random integers from `low` (inclusive) to `high` (exclusive).</span>
<span class="sd">    Return random integers from the &quot;discrete uniform&quot; distribution of</span>
<span class="sd">    the specified dtype in the &quot;half-open&quot; interval [`low`, `high`). If</span>
<span class="sd">    `high` is None (the default), then results are from [0, `low`).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    low : int</span>
<span class="sd">        Lowest (signed) integer to be drawn from the distribution (unless</span>
<span class="sd">        ``high=None``, in which case this parameter is one above the</span>
<span class="sd">        *highest* such integer).</span>
<span class="sd">    high : int, optional</span>
<span class="sd">        If provided, one above the largest (signed) integer to be drawn</span>
<span class="sd">        from the distribution.</span>
<span class="sd">    size : int or tuple of ints, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  Default is None, in which case a</span>
<span class="sd">        single value is returned.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Desired dtype of the result. Byteorder must be native.</span>
<span class="sd">        The default value is int.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array of random ints</span>
<span class="sd">        `size`-shaped array of random integers from the appropriate</span>
<span class="sd">        distribution, or a single such random int if `size` not provided.</span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.random.random_integers` : similar to `randint`, only for the closed</span>
<span class="sd">                                         interval [`low`, `high`], and 1 is the</span>
<span class="sd">                                         lowest value if `high` is omitted.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">low</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;randint&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;randint&quot;</span><span class="p">,</span> <span class="s2">&quot;type(size)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">high</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">low</span>
            <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">low</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">low</span><span class="p">)</span>
        <span class="n">high</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">high</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">low</span> <span class="o">&gt;=</span> <span class="n">high</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;randint&quot;</span><span class="p">,</span> <span class="s2">&quot;low&quot;</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>

        <span class="n">_dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># TODO:</span>
        <span class="c1"># supported only int32</span>
        <span class="c1"># or just raise error when dtype != numpy.int32</span>
        <span class="k">if</span> <span class="n">_dtype</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span> <span class="ow">or</span> <span class="n">_dtype</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">:</span>
            <span class="n">_dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unsupported dtype </span><span class="si">%r</span><span class="s1"> for randint&#39;</span> <span class="o">%</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dpnp_uniform</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">_dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="randn"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.randn.html#dpnp.random.randn">[docs]</a><span class="k">def</span> <span class="nf">randn</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span> <span class="o">*</span><span class="n">dn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If positive int_like arguments are provided, randn generates an array of shape (d0, d1, ..., dn),</span>
<span class="sd">    filled with random floats sampled from a univariate “normal” (Gaussian) distribution of mean 0 and variance 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d0, d1, …, dn : The dimensions of the returned array, must be non-negative.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : (d0, d1, ..., dn)-shaped array of floating-point samples from the standard normal distribution.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.random.standard_normal`</span>
<span class="sd">    :obj:`dpnp.random.normal`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">d0</span><span class="p">):</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">d0</span><span class="p">,</span> <span class="o">*</span><span class="n">dn</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;randn&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dpnp_randn</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">,</span> <span class="n">d0</span><span class="p">,</span> <span class="o">*</span><span class="n">dn</span><span class="p">)</span></div>


<div class="viewcode-block" id="random"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.random.html#dpnp.random.random">[docs]</a><span class="k">def</span> <span class="nf">random</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return random floats in the half-open interval [0.0, 1.0).</span>
<span class="sd">    Alias for random_sample.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    size : Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : Array of random floats of shape size.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.random.random`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;random&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dpnp_random</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="random_integers"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.random_integers.html#dpnp.random.random_integers">[docs]</a><span class="k">def</span> <span class="nf">random_integers</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    random_integers(low, high=None, size=None)</span>

<span class="sd">    Random integers between `low` and `high`, inclusive.</span>
<span class="sd">    Return random integers from the &quot;discrete uniform&quot; distribution in</span>
<span class="sd">    the closed interval [`low`, `high`].  If `high` is</span>
<span class="sd">    None (the default), then results are from [1, `low`].</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    low : int</span>
<span class="sd">        Lowest (signed) integer to be drawn from the distribution (unless</span>
<span class="sd">        ``high=None``, in which case this parameter is the *highest* such</span>
<span class="sd">        integer).</span>
<span class="sd">    high : int, optional</span>
<span class="sd">        If provided, the largest (signed) integer to be drawn from the</span>
<span class="sd">        distribution (see above for behavior if ``high=None``).</span>
<span class="sd">    size : int or tuple of ints, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  Default is None, in which case a</span>
<span class="sd">        single value is returned.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array of random ints</span>
<span class="sd">        `size`-shaped array of random integers from the appropriate</span>
<span class="sd">        distribution, or a single such random int if `size` not provided.</span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.random.randint`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">low</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">high</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">low</span>
            <span class="n">low</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">high</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_integers</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="random_sample"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.random_sample.html#dpnp.random.random_sample">[docs]</a><span class="k">def</span> <span class="nf">random_sample</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return random floats in the half-open interval [0.0, 1.0).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    size : Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : Array of random floats of shape size.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.random.random`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;random_sample&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dpnp_random</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="ranf"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.ranf.html#dpnp.random.ranf">[docs]</a><span class="k">def</span> <span class="nf">ranf</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return random floats in the half-open interval [0.0, 1.0).</span>
<span class="sd">    This is an alias of random_sample.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    size : Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : Array of random floats of shape size.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.random.random`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;ranf&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dpnp_random</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">ranf</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="rayleigh"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.rayleigh.html#dpnp.random.rayleigh">[docs]</a><span class="k">def</span> <span class="nf">rayleigh</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rayleigh distribution.</span>

<span class="sd">    Draw samples from a Rayleigh distribution.</span>

<span class="sd">    The :math:`\\chi` and Weibull distributions are generalizations of the</span>
<span class="sd">    Rayleigh.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    scale : float, optional</span>
<span class="sd">        Scale, also equals the mode. Must be non-negative. Default is 1.</span>
<span class="sd">    size : int or tuple of ints, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  If size is ``None`` (default),</span>
<span class="sd">        a single value is returned if ``scale`` is a scalar.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dparray</span>
<span class="sd">        Drawn samples from the parameterized Rayleigh distribution.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">scale</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;rayleigh&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;rayleigh&quot;</span><span class="p">,</span> <span class="s2">&quot;type(size)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="c1"># TODO:</span>
        <span class="c1"># array_like of floats for `scale` params</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;rayleigh&quot;</span><span class="p">,</span> <span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="s2">&quot;non-negative&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dpnp_rayleigh</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rayleigh</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="sample"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.sample.html#dpnp.random.sample">[docs]</a><span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return random floats in the half-open interval [0.0, 1.0).</span>
<span class="sd">    This is an alias of random_sample.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    size : Output shape. If the given shape is, e.g., (m, n, k), then m * n * k samples are drawn.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : Array of random floats of shape size.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.random.random`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;sample&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dpnp_random</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="seed"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.seed.html#dpnp.random.seed">[docs]</a><span class="k">def</span> <span class="nf">seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reseed a legacy philox4x32x10 random number generator engine</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seed : {None, int}, optional</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
        <span class="c1"># TODO:</span>
        <span class="c1"># implement seed default value as is in numpy</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;seed&quot;</span><span class="p">,</span> <span class="s2">&quot;type(seed)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">seed</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">seed</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;seed&quot;</span><span class="p">,</span> <span class="s2">&quot;seed&quot;</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="s2">&quot;non-negative&quot;</span><span class="p">)</span>
        <span class="n">dpnp_srand</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span></div>


<div class="viewcode-block" id="standard_cauchy"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.standard_cauchy.html#dpnp.random.standard_cauchy">[docs]</a><span class="k">def</span> <span class="nf">standard_cauchy</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Standard cauchy distribution.</span>

<span class="sd">    Draw samples from a standard Cauchy distribution with mode = 0.</span>

<span class="sd">    Also known as the Lorentz distribution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    size : int, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    samples : dparray</span>
<span class="sd">        The drawn samples.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Draw samples and plot the distribution:</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; s = dpnp.random.standard_cauchy(1000000)</span>
<span class="sd">    &gt;&gt;&gt; s = s[(s&gt;-25) &amp; (s&lt;25)]  # truncate distribution so it plots well</span>
<span class="sd">    &gt;&gt;&gt; plt.hist(s, bins=100)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;standard_cauchy&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;standard_cauchy&quot;</span><span class="p">,</span> <span class="s2">&quot;type(size)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dpnp_standard_cauchy</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_cauchy</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="standard_exponential"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.standard_exponential.html#dpnp.random.standard_exponential">[docs]</a><span class="k">def</span> <span class="nf">standard_exponential</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Standard exponential distribution.</span>

<span class="sd">    Draw samples from the standard exponential distribution.</span>

<span class="sd">    `standard_exponential` is identical to the exponential distribution</span>
<span class="sd">    with a scale parameter of 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    size : int or tuple of ints, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  Default is None, in which case a</span>
<span class="sd">        single value is returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dparray</span>
<span class="sd">        Drawn samples.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Output a 3x8000 array:</span>
<span class="sd">    &gt;&gt;&gt; n = dpnp.random.standard_exponential((3, 8000))</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;standard_exponential&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;standard_exponential&quot;</span><span class="p">,</span> <span class="s2">&quot;type(size)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dpnp_standard_exponential</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_exponential</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="standard_gamma"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.standard_gamma.html#dpnp.random.standard_gamma">[docs]</a><span class="k">def</span> <span class="nf">standard_gamma</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Standard gamma distribution.</span>

<span class="sd">    Draw samples from a standard Gamma distribution.</span>

<span class="sd">    Samples are drawn from a Gamma distribution with specified parameters,</span>
<span class="sd">    shape (sometimes designated &quot;k&quot;) and scale=1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : float</span>
<span class="sd">        Parameter, must be non-negative.</span>
<span class="sd">    size : int or tuple of ints, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  If size is ``None`` (default),</span>
<span class="sd">        a single value is returned if ``shape`` is a scalar.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dparray</span>
<span class="sd">        Drawn samples from the parameterized standard gamma distribution.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The probability density for the Gamma distribution is</span>

<span class="sd">    .. math:: p(x) = x^{k-1}\\frac{e^{-x/\\theta}}{\\theta^k\\Gamma(k)},</span>

<span class="sd">    where :math:`k` is the shape and :math:`\\theta` the scale,</span>
<span class="sd">    and :math:`\\Gamma` is the Gamma function.</span>

<span class="sd">    The Gamma distribution is often used to model the times to failure of</span>
<span class="sd">    electronic components, and arises naturally in processes for which the</span>
<span class="sd">    waiting times between Poisson distributed events are relevant.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Weisstein, Eric W. &quot;Gamma Distribution.&quot; From MathWorld--A</span>
<span class="sd">           Wolfram Web Resource.</span>
<span class="sd">           http://mathworld.wolfram.com/GammaDistribution.html</span>
<span class="sd">    .. [2] Wikipedia, &quot;Gamma distribution&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Gamma_distribution</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Draw samples from the distribution:</span>
<span class="sd">    &gt;&gt;&gt; shape = 2. # mean and width</span>
<span class="sd">    &gt;&gt;&gt; s = dpnp.random.standard_gamma(shape, 1000000)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO:</span>
    <span class="c1"># array_like of floats for and `shape`</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dpnp_queue_is_cpu</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;standard_gamma&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;standard_gamma&quot;</span><span class="p">,</span> <span class="s2">&quot;type(size)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shape</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;standard_gamma&quot;</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;non-negative&quot;</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">dpnp_standard_gamma</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_gamma</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="standard_normal"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.standard_normal.html#dpnp.random.standard_normal">[docs]</a><span class="k">def</span> <span class="nf">standard_normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Standard normal distribution.</span>

<span class="sd">    Draw samples from a standard Normal distribution (mean=0, stdev=1).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    size : int, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  Default is None, in which case a</span>
<span class="sd">        single value is returned.</span>
<span class="sd"> </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : float or ndarray</span>
<span class="sd">        A floating-point array of shape ``size`` of drawn samples, or a</span>
<span class="sd">        single sample if ``size`` was not specified.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;standard_normal&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;standard_normal&quot;</span><span class="p">,</span> <span class="s2">&quot;type(size)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dpnp_standard_normal</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="uniform"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.uniform.html#dpnp.random.uniform">[docs]</a><span class="k">def</span> <span class="nf">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    uniform(low=0.0, high=1.0, size=None)</span>

<span class="sd">    Draw samples from a uniform distribution.</span>
<span class="sd">    Samples are uniformly distributed over the half-open interval</span>
<span class="sd">    ``[low, high)`` (includes low, but excludes high).  In other words,</span>
<span class="sd">    any value within the given interval is equally likely to be drawn</span>
<span class="sd">    by `uniform`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    low : float, optional</span>
<span class="sd">        Lower boundary of the output interval.  All values generated will be</span>
<span class="sd">        greater than or equal to low.  The default value is 0.</span>
<span class="sd">    high : float</span>
<span class="sd">        Upper boundary of the output interval.  All values generated will be</span>
<span class="sd">        less than high.  The default value is 1.0.</span>
<span class="sd">    size : int or tuple of ints, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  If size is ``None`` (default),</span>
<span class="sd">        a single value is returned if ``low`` and ``high`` are both scalars.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array or scalar</span>
<span class="sd">        Drawn samples from the parameterized uniform distribution.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.random.random` : Floats uniformly distributed over ``[0, 1)``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">low</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">low</span> <span class="o">==</span> <span class="n">high</span><span class="p">:</span>
            <span class="c1"># TODO:</span>
            <span class="c1"># currently dparray.full is not implemented</span>
            <span class="c1"># return dpnp.dparray.dparray.full(size, low, dtype=numpy.float64)</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;`low` equal to `high`, should return an array, filled with `low` value.&quot;</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;  Currently not supported. See: numpy.full TODO&quot;</span>
            <span class="n">checker_throw_runtime_error</span><span class="p">(</span><span class="s2">&quot;uniform&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">low</span> <span class="o">&gt;</span> <span class="n">high</span><span class="p">:</span>
            <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">high</span><span class="p">,</span> <span class="n">low</span>
        <span class="k">return</span> <span class="n">dpnp_uniform</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="weibull"><a class="viewcode-back" href="../../../reference/generated/dpnp.random.weibull.html#dpnp.random.weibull">[docs]</a><span class="k">def</span> <span class="nf">weibull</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Draw samples from a Weibull distribution.</span>

<span class="sd">    Draw samples from a 1-parameter Weibull distribution with the given</span>
<span class="sd">    shape parameter `a`.</span>

<span class="sd">    .. math:: X = (-ln(U))^{1/a}</span>

<span class="sd">    Here, U is drawn from the uniform distribution over (0,1].</span>
<span class="sd">    The more common 2-parameter Weibull, including a scale parameter</span>
<span class="sd">    :math:`\\lambda` is just :math:`X = \\lambda(-ln(U))^{1/a}`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : float</span>
<span class="sd">        Shape parameter of the distribution.  Must be nonnegative.</span>
<span class="sd">    size : int or tuple of ints, optional</span>
<span class="sd">        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then</span>
<span class="sd">        ``m * n * k`` samples are drawn.  If size is ``None`` (default),</span>
<span class="sd">        a single value is returned if ``a`` is a scalar.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray or scalar</span>
<span class="sd">        Drawn samples from the parameterized Weibull distribution.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = 5. # shape</span>
<span class="sd">    &gt;&gt;&gt; s = np.random.weibull(a, 1000)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_origin_backend</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;weibull&quot;</span><span class="p">,</span> <span class="s2">&quot;type(dim)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;weibull&quot;</span><span class="p">,</span> <span class="s2">&quot;type(size)&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

        <span class="c1"># TODO:</span>
        <span class="c1"># array_like of floats for `a` params</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">checker_throw_value_error</span><span class="p">(</span><span class="s2">&quot;weibulla&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="s2">&quot;non-negative&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dpnp_weibull</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">weibull</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Intel

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>